<!DOCTYPE html>
<html>
<head>
    <title>VRM CMU Animation Cycler</title>
    <meta name="description" content="Randomly cycles through CMU mocap animations on random VRM models">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">

    <script src="js/aframe-v1.7.1.js"></script>
    <script src="js/aframe-environment-component.js"></script>

    <!-- Official three-vrm libraries -->
    <script src="js/three-vrm.js"></script>
    <script src="js/three-vrm-animation.js"></script>

    <!-- Custom A-Frame VRM component bundle -->
    <script src="js/aframe-vrm-bundle.js"></script>
</head>

<body>

<style>
#info-panel {
    position: fixed;
    top: 10px;
    left: 10px;
    width: 400px;
    background: rgba(0,0,0,0.8);
    color: #0f0;
    font-family: monospace;
    font-size: 12px;
    padding: 15px;
    z-index: 1000;
    border: 1px solid #0f0;
}
#info-panel h3 {
    margin: 0 0 10px 0;
    color: #0ff;
}
.control-group {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #0a5;
}
.slider-container {
    margin: 5px 0;
}
.slider-container input[type="range"] {
    width: 100%;
    margin: 5px 0;
}
.slider-label {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: #0ff;
}
</style>

<div id="info-panel">
    <h3>VRM CMU Animation Cycler</h3>
    <div>Model: <span id="current-model">Loading...</span></div>
    <div>Animation: <span id="current-anim">None</span></div>
    <div>Next in: <span id="countdown">-</span>s</div>

    <div class="control-group">
        <div class="slider-container">
            <div class="slider-label">
                <span>Leg Spread</span>
                <span id="leg-spread-value">0.00</span>
            </div>
            <input type="range" id="leg-spread-slider" min="-1" max="1" step="0.05" value="0">
        </div>
    </div>

    <div style="margin-top: 10px; font-size: 10px; color: #0a5;">
        Animation loops continuously. Cycles every 10s with 2s blend.
    </div>
</div>

<script>
// Available VRM models (subset for quick loading)
const VRM_MODELS = [
    'models/Asian/Asian_F_1_Busi.vrm',
    'models/Hispanic/Hispanic_M_1_Casual.vrm',
    'models/AIAN/AIAN_F_1_Util.vrm',
    'models/NHPI/NHPI_M_1_Busi.vrm'
];

// Available CMU animations
const CMU_ANIMATIONS = [
    'vrma/01_02.vrma'
];
// Pick random model
const randomModel = VRM_MODELS[Math.floor(Math.random() * VRM_MODELS.length)];
console.log('Selected model:', randomModel);
document.getElementById('current-model').textContent = randomModel.split('/').pop();



// Animation cycler component
AFRAME.registerComponent('anim-cycler', {
    schema: {
        interval: { default: 15000 },  // 15 seconds per animation
        blendDuration: { default: 2.0 }  // 2 second crossfade
    },

    init: function () {
        this.vrm = null;
        this.mixer = null;
        this.currentAction = null;
        this.previousAction = null; // Added for blending
        this.animIndex = 0;
        this.timer = 0;
        this.countdown = this.data.interval / 1000;

        // Wait for VRM to load
        this.el.addEventListener('model-loaded', (e) => {
            this.vrm = e.detail.vrm;
            this.mixer = this.el.components.vrm.mixer;
            console.log('VRM loaded, starting animation cycle');

            // Load first animation
            this.loadAnimation(0);
        });
    },

    loadAnimation: async function (index) {
        if (!this.vrm || !this.mixer) return;

        const animUrl = CMU_ANIMATIONS[index];
        console.log('Loading animation:', animUrl);
        document.getElementById('current-anim').textContent = animUrl.split('/').pop();

        const loader = new THREE.GLTFLoader();
        loader.register((parser) => {
          const plugin = new THREE.VRMAnimationLoaderPlugin(parser);
          const originalAfterRoot = plugin.afterRoot.bind(plugin);
          plugin.afterRoot = async function(gltf) {
            if (gltf.parser.json.extensions && gltf.parser.json.extensions.VRMC_vrm_animation) {
              const vrmcAnim = gltf.parser.json.extensions.VRMC_vrm_animation;
              if (!vrmcAnim.specVersion) {
                vrmcAnim.specVersion = '1.0';
              }
            }
            return originalAfterRoot(gltf);
          };
          return plugin;
        });

        try {
            const gltf = await loader.loadAsync(animUrl);

            if (gltf.userData.vrmAnimations && gltf.userData.vrmAnimations.length > 0) {
                const vrmAnimation = gltf.userData.vrmAnimations[0];
                const clip = THREE.createVRMAnimationClip(vrmAnimation, this.vrm);

                if (clip) {
                    this.previousAction = this.currentAction; // Store current action as previous

                    // Create and play new action
                    this.currentAction = this.mixer.clipAction(clip);
                    this.currentAction.loop = THREE.LoopRepeat;
                    this.currentAction.clampWhenFinished = false;
                    this.currentAction.enabled = true;
                    this.currentAction.timeScale = 1.0;
                    this.currentAction.setEffectiveWeight(0.0); // Start with 0 weight for blending
                    this.currentAction.reset();
                    this.currentAction.play();

                    // Crossfade from previous action
                    if (this.previousAction) {
                        this.currentAction.crossFadeFrom(this.previousAction, this.data.blendDuration, false);
                    } else {
                        this.currentAction.setEffectiveWeight(1.0); // If no previous action, set full weight immediately
                    }

                    console.log('Animation playing:', animUrl, 'duration:', clip.duration);
                }
            }
        } catch (error) {
            console.error('Error loading animation:', error);
        }
    },

    tick: function (time, deltaTime) {
        if (!this.currentAction) return;

        // Update timer
        this.timer += deltaTime;

        // Update countdown display
        const remaining = Math.max(0, (this.data.interval - this.timer) / 1000);
        this.countdown = Math.ceil(remaining);
        document.getElementById('countdown').textContent = this.countdown;

        // Check if it's time to load next animation
        if (this.timer >= this.data.interval) {
            this.timer = 0;
            this.animIndex = (this.animIndex + 1) % CMU_ANIMATIONS.length;
            this.loadAnimation(this.animIndex);
        }
    },

    remove: function () {
        if (this.currentAction) {
            this.currentAction.stop();
        }
    }
});

// Component to adjust leg spread
AFRAME.registerComponent('leg-fixer', {
    schema: {
        spread: {type: 'number', default: 0.0 }
    },
    init: function () {
        this.vrm = null;
        this.leftUpperLeg = null;
        this.rightUpperLeg = null;
        this.zAxis = new THREE.Vector3(0, 0, 1);
        this.leftOffset = new THREE.Quaternion();
        this.rightOffset = new THREE.Quaternion();

        this.el.addEventListener('model-loaded', (e) => {
            this.vrm = e.detail.vrm;
            if (!this.vrm.humanoid) {
                console.error("VRM humanoid bones not found.");
                return;
            }
            // Using strings for bone names as they are consistent identifiers
            this.leftUpperLeg = this.vrm.humanoid.getBoneNode('leftUpperLeg');
            this.rightUpperLeg = this.vrm.humanoid.getBoneNode('rightUpperLeg');

            if (!this.leftUpperLeg || !this.rightUpperLeg) {
                console.error("Could not find upper leg bones!");
            }
        });

        const slider = document.getElementById('leg-spread-slider');
        if (slider) {
            slider.addEventListener('input', (event) => {
                this.el.setAttribute('leg-fixer', 'spread', event.target.value);
                const spreadValueSpan = document.getElementById('leg-spread-value');
                if(spreadValueSpan) spreadValueSpan.textContent = parseFloat(event.target.value).toFixed(2);
            });
        }
    },
    tick: function () {
        if (!this.leftUpperLeg || !this.rightUpperLeg) { return; }

        // The vrm component's tick updates the animation mixer.
        // This component's tick runs after, so we can modify the bone quaternions
        // right after animation has been applied and before rendering.
        // The rotation is applied in the bone's local space.
        
        const spreadAngle = this.data.spread * Math.PI / 4; // Max 45 degrees spread/cross

        this.leftOffset.setFromAxisAngle(this.zAxis, spreadAngle);
        this.rightOffset.setFromAxisAngle(this.zAxis, -spreadAngle);
        
        this.leftUpperLeg.quaternion.premultiply(this.leftOffset);
        this.rightUpperLeg.quaternion.premultiply(this.rightOffset);
    }
});
</script>

<a-scene>
    <a-sky color="#001a33"></a-sky>

    <!-- Ground plane -->
    <a-plane
        position="0 0 0"
        rotation="-90 0 0"
        width="50"
        height="50"
        color="#003366"
        shadow="receive: true">
    </a-plane>

    <!-- VRM Avatar with animation cycler and leg fix -->
    <a-entity
        id="avatar"
        vrm="src: ;"
        anim-cycler
        leg-fixer
        position="0 0 -4"
        rotation="0 180 0"
        shadow="cast: true; receive: false;">
    </a-entity>

    <!-- Lighting -->
    <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
    <a-entity light="type: directional; intensity: 0.8; castShadow: true;" position="2 4 2"></a-entity>

    <!-- Camera -->
    <a-entity position="0 1.6 1">
        <a-camera></a-camera>
    </a-entity>
</a-scene>

<script>
// Set the random model after A-Frame is initialized
setTimeout(() => {
    document.getElementById('avatar').setAttribute('vrm', 'src', randomModel);
}, 100);
</script>

</body>
</html>